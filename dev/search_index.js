var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"module_index/","page":"API","title":"API","text":"","category":"page"},{"location":"module_index/","page":"API","title":"API","text":"Modules = [AngularPowerSpectra]","category":"page"},{"location":"module_index/#AngularPowerSpectra.channelindex-Tuple{Any}","page":"API","title":"AngularPowerSpectra.channelindex","text":"channelindex(s)\n\nConvert string/char T,E,B => 1,2,3\n\nExamples\n\njulia> channelindex(\"E\")\n2\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.clquickpol-Union{Tuple{SV}, Tuple{T}, Tuple{Any,Any,SV,SV,Any,Any,Any,Any}} where SV<:(OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray) where T","page":"API","title":"AngularPowerSpectra.clquickpol","text":"clquickpol(nu₁, nu₂, b₁, b₂, ρ₁, ρ₂, ω₁, ω₂)\n\nCompute the cross-power spectrum of two maps with spins nu_1 and nu_2 (Hivon et al. 2016, eq. 38)\n\nbeginaligned\ntildeC_ell^primeprime^nu_1 nu_2  = sum_u_1 u_2 j_1 j_2 ell s_1 s_2\n    (-1)^s_1 + s_1 + nu_1 + nu_2 C_ell^u_1 u_2 frac2ell+14pi\n    _u_1hatb^(j_1)*_ell s_1 _u_2hatb^(j_2)*_ell s_2 \nqquadqquad times frack_u_1 k_u_2k_nu_1k_nu_2 sum_ell^prime m^prime\n    rho_j_1 nu_1 rho_j_2 nu_2 (_s_1+nu_1tildeomega^(j_1)_ell^prime m^prime)\n    (_s_2+nu_2tildeomega^(j_2)_ell^prime m^prime)^* \nqquadqquad times beginpmatrix ell  ell^prime  ell^primeprime \n    -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n    ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\nArguments:\n\nnu₁: spin of the first map\nnu₂: spin of the second map\nb₁::SpectralVector: inverse noise-weighted beam multipoles for the first map\nb₂::SpectralVector: inverse noise-weighted beam multipoles for the second map\nρ₁: polarization efficiency\nρ₂: polarization efficiency\nω₁: effective weights describing the scanning of the first map\nω₂: effective weights describing the scanning of the second map\n\nReturns:\n\nSpectralVector: The cross-power spectrum of the two provided maps.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.decouple_covmat-Union{Tuple{SA}, Tuple{T}, Tuple{SA,SA,SA}} where SA<:(OffsetArrays.OffsetArray{T,2,AA} where AA<:AbstractArray) where T","page":"API","title":"AngularPowerSpectra.decouple_covmat","text":"decouple_covmat(Y, B1, B2; lmin1=2, lmin2=2)\n\nDecouples a covariance matrix Y, performing B₁⁻¹ × M × (B₂⁻¹)^† by mutating M. Zeros out ℓ₁, ℓ₂ within BOTH lmin1 and lmin2 (i.e the corner).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.map2cl-Union{Tuple{T}, Tuple{Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,LinearAlgebra.Factorization,OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray,OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray}} where T","page":"API","title":"AngularPowerSpectra.map2cl","text":"map2cl(...)\n\nArguments:\n\nmap_1::Map{T}: masked map\nmap_2::Map{T}: masked map\nfactorized_mcm::Factorization: lu(mode coupling matrix)\nBℓ_1::SpectralVector{T}: beam associated with first map\nBℓ_2::SpectralVector{T}: beam associated with second map\n\nReturns:\n\nArray{T,1}: spectrum\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mask!-Union{Tuple{T}, Tuple{Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order}} where T","page":"API","title":"AngularPowerSpectra.mask!","text":"mask!\n\nConvenience function for applying a mask to a map.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mcm-Union{Tuple{T}, Tuple{SpectralWorkspace{T},String,String,String}} where T","page":"API","title":"AngularPowerSpectra.mcm","text":"mcm(workspace::SpectralWorkspace{T}, spec::MapType, f1_name::String, f2_name::String) where {T}\n\nArguments:\n\nworkspace::SpectralWorkspace{T}: stores the SHTs of the masks\nspec::String: the spectrum to compute, such as \"TT\", \"TE\", or \"EE\"\nf1_name::String: the name of the first field\nf2_name::String: the name of the second field\n\nReturns:\n\nSpectralArray{T,2}: zero-indexed array containing the mode-coupling matrix\n\nExamples\n\nm1 = PolarizedField(\"field1\", mask1_T, mask1_P)\nm2 = PolarizedField(\"field2\", mask2_T, mask2_P)\nworkspace = SpectralWorkspace(m1, m2)\n𝐌 = mcm(workspace, spec, \"field1\", \"field2\")\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm!-Union{Tuple{T}, Tuple{Random.AbstractRNG,AbstractArray{T,3},Array{T,1} where T}} where T","page":"API","title":"AngularPowerSpectra.synalm!","text":"synalm!([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, alms::Vector{Alm{Complex{T}}}) where T\n\nIn-place synthesis of spherical harmonic coefficients, given spectra.\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nalms::Vector: array of Alm to fill\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = [Alm{Complex{Float64}}(3nside-1, 3nside-1) for i in 1:2]\nsynalm!(Cl, alms)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm-Union{Tuple{T}, Tuple{Random.AbstractRNG,AbstractArray{T,3},Int64}} where T","page":"API","title":"AngularPowerSpectra.synalm","text":"synalm([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, nside::Int) where T\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nnside::Int: healpix resolution\n\nReturns:\n\nVector{Alm{T}}: spherical harmonics realizations for each component\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = synalm(Cl, nside)\n\n\n\n\n\n","category":"method"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"spectra/#Spectral-Analysis","page":"Spectra","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"using Healpix\nusing AngularPowerSpectra\n\n# load up a mask\nnside = 256\nmask = readMapFromFITS(\"test/data/example_mask_1.fits\", 1, Float64)\n\n# pretend we are computing 143 GHz fields between two half-missions, hm1 and hm2\nm1 = PolarizedField(\"143_hm1\", mask, mask)\nm2 = PolarizedField(\"143_hm2\", mask, mask)\nworkspace = SpectralWorkspace(m1, m2)\n\n# compute the mode-coupling matrix\nM = mcm(workspace, \"TT\", \"143_hm1\", \"143_hm2\")","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"covariance/#Covariance-Estimation","page":"Covariance","title":"Covariance Estimation","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"(interface needs to be cleaned up)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"#AngularPowerSpectra","page":"Home","title":"AngularPowerSpectra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AngularPowerSpectra.jl computes mode-coupling matrices and covariance matrices for TT, TE, and EE spectra, using pseudo-C_ell methods (i.e. Hivon et al. 2002, Efstathiou 2006, Hamimeche and Lewis 2008).","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"beams/#QuickPol","page":"Beams","title":"QuickPol","text":"","category":"section"},{"location":"beams/","page":"Beams","title":"Beams","text":"clquickpol","category":"page"},{"location":"beams/#AngularPowerSpectra.clquickpol","page":"Beams","title":"AngularPowerSpectra.clquickpol","text":"clquickpol(nu₁, nu₂, b₁, b₂, ρ₁, ρ₂, ω₁, ω₂)\n\nCompute the cross-power spectrum of two maps with spins nu_1 and nu_2 (Hivon et al. 2016, eq. 38)\n\nbeginaligned\ntildeC_ell^primeprime^nu_1 nu_2  = sum_u_1 u_2 j_1 j_2 ell s_1 s_2\n    (-1)^s_1 + s_1 + nu_1 + nu_2 C_ell^u_1 u_2 frac2ell+14pi\n    _u_1hatb^(j_1)*_ell s_1 _u_2hatb^(j_2)*_ell s_2 \nqquadqquad times frack_u_1 k_u_2k_nu_1k_nu_2 sum_ell^prime m^prime\n    rho_j_1 nu_1 rho_j_2 nu_2 (_s_1+nu_1tildeomega^(j_1)_ell^prime m^prime)\n    (_s_2+nu_2tildeomega^(j_2)_ell^prime m^prime)^* \nqquadqquad times beginpmatrix ell  ell^prime  ell^primeprime \n    -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n    ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\nArguments:\n\nnu₁: spin of the first map\nnu₂: spin of the second map\nb₁::SpectralVector: inverse noise-weighted beam multipoles for the first map\nb₂::SpectralVector: inverse noise-weighted beam multipoles for the second map\nρ₁: polarization efficiency\nρ₂: polarization efficiency\nω₁: effective weights describing the scanning of the first map\nω₂: effective weights describing the scanning of the second map\n\nReturns:\n\nSpectralVector: The cross-power spectrum of the two provided maps.\n\n\n\n\n\n","category":"function"}]
}
