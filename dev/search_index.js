var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"module_index/","page":"API","title":"API","text":"","category":"page"},{"location":"module_index/","page":"API","title":"API","text":"Modules = [AngularPowerSpectra]","category":"page"},{"location":"module_index/#AngularPowerSpectra.channelindex-Tuple{Any}","page":"API","title":"AngularPowerSpectra.channelindex","text":"channelindex(s)\n\nConvert string/char T,E,B => 1,2,3\n\nExamples\n\njulia> channelindex(\"E\")\n2\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.decouple_covmat-Union{Tuple{SA}, Tuple{T}, Tuple{SA,SA,SA}} where SA<:(OffsetArrays.OffsetArray{T,2,AA} where AA<:AbstractArray) where T","page":"API","title":"AngularPowerSpectra.decouple_covmat","text":"decouple_covmat(Y, B1, B2; lmin1=2, lmin2=2)\n\nDecouples a covariance matrix Y, performing B₁⁻¹ × M × (B₂⁻¹)^† by mutating M. Zeros out ℓ₁, ℓ₂ within BOTH lmin1 and lmin2 (i.e the corner).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.kᵤ-Tuple{Type,Any}","page":"API","title":"AngularPowerSpectra.kᵤ","text":"kᵤ([T=Float64], u)\n\nDefined only for u ∈ {-2, 0, 2}.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.map2cl-Union{Tuple{T}, Tuple{Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,LinearAlgebra.Factorization,OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray,OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray}} where T","page":"API","title":"AngularPowerSpectra.map2cl","text":"map2cl(...)\n\nArguments:\n\nmap_1::Map{T}: masked map\nmap_2::Map{T}: masked map\nfactorized_mcm::Factorization: lu(mode coupling matrix)\nBℓ_1::SpectralVector{T}: beam associated with first map\nBℓ_2::SpectralVector{T}: beam associated with second map\n\nReturns:\n\nArray{T,1}: spectrum\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mask!-Union{Tuple{T}, Tuple{Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order,Healpix.Map{T,O,AA} where AA<:AbstractArray{T,1} where O<:Healpix.Order}} where T","page":"API","title":"AngularPowerSpectra.mask!","text":"mask!\n\nConvenience function for applying a mask to a map.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.mcm-Union{Tuple{T}, Tuple{SpectralWorkspace{T},String,String,String}} where T","page":"API","title":"AngularPowerSpectra.mcm","text":"mcm(workspace::SpectralWorkspace{T}, spec::MapType, f1_name::String, f2_name::String) where {T}\n\nArguments:\n\nworkspace::SpectralWorkspace{T}: stores the SHTs of the masks\nspec::String: the spectrum to compute, such as \"TT\", \"TE\", or \"EE\"\nf1_name::String: the name of the first field\nf2_name::String: the name of the second field\n\nReturns:\n\nSpectralArray{T,2}: zero-indexed array containing the mode-coupling matrix\n\nExamples\n\nm1 = PolarizedField(\"field1\", mask1_T, mask1_P)\nm2 = PolarizedField(\"field2\", mask2_T, mask2_P)\nworkspace = SpectralWorkspace(m1, m2)\n𝐌 = mcm(workspace, spec, \"field1\", \"field2\")\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.quickpolW-Union{Tuple{T}, Tuple{Healpix.Alm{Complex{T},AA} where AA<:AbstractArray{Complex{T},1},Healpix.Alm{Complex{T},AA} where AA<:AbstractArray{Complex{T},1}}} where T<:Number","page":"API","title":"AngularPowerSpectra.quickpolW","text":"quickpolW(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scanned pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime  left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.quickpolΞ!-Union{Tuple{AA}, Tuple{T}, Tuple{AA,Any,Any,Any,Any,Healpix.Alm,Healpix.Alm,Array{Array{T,1},1},Array{Array{T,1},1}}} where AA<:(OffsetArrays.OffsetArray{T,2,AA} where AA<:AbstractArray) where T","page":"API","title":"AngularPowerSpectra.quickpolΞ!","text":"quickpolΞ!(𝚵::AA, ν₁, ν₂, s₁, s₂, ω₁, ω₂)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nω₁: effective scan weights with spin s₁ + ν₁\nω₂: effective scan weights with spin s₂ + ν₂\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm!-Union{Tuple{T}, Tuple{Random.AbstractRNG,AbstractArray{T,3},Array{T,1} where T}} where T","page":"API","title":"AngularPowerSpectra.synalm!","text":"synalm!([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, alms::Vector{Alm{Complex{T}}}) where T\n\nIn-place synthesis of spherical harmonic coefficients, given spectra.\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nalms::Vector: array of Alm to fill\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = [Alm{Complex{Float64}}(3nside-1, 3nside-1) for i in 1:2]\nsynalm!(Cl, alms)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.synalm-Union{Tuple{T}, Tuple{Random.AbstractRNG,AbstractArray{T,3},Int64}} where T","page":"API","title":"AngularPowerSpectra.synalm","text":"synalm([rng=GLOBAL_RNG], Cl::AbstractArray{T,3}, nside::Int) where T\n\nArguments:\n\nCl::AbstractArray{T,3}: array with dimensions of comp, comp, ℓ\nnside::Int: healpix resolution\n\nReturns:\n\nVector{Alm{T}}: spherical harmonics realizations for each component\n\nExamples\n\nnside = 16\nC0 = [3.  2.;  2.  5.]\nCl = repeat(C0, 1, 1, 3nside)  # spectra constant with ℓ\nalms = synalm(Cl, nside)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#AngularPowerSpectra.Ξsum-Union{Tuple{T}, Tuple{OffsetArrays.OffsetArray{T,1,AA} where AA<:AbstractArray,WignerFamilies.WignerSymbolVector{T,Int64,AA} where AA<:AbstractArray{T,1},WignerFamilies.WignerSymbolVector{T,Int64,AA} where AA<:AbstractArray{T,1}}} where T<:Number","page":"API","title":"AngularPowerSpectra.Ξsum","text":"Ξsum(alm₁, alm₂, w3j₁, w3j₂)\n\nSum over ell and m of two a_ell m and nontrivial Wigner-3j vectors. This is  a step in computing the mathbfXi matrix. The rho factors are not  in this summation, as they can be pulled out.\n\nbeginaligned\n(Xi mathrmsum) = sum_ell^prime m^prime   W_ell^nu_1nu_2s_1s_2j_1j_2 times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"spectra/#Spectral-Analysis","page":"Spectra","title":"Spectral Analysis","text":"","category":"section"},{"location":"spectra/","page":"Spectra","title":"Spectra","text":"using Healpix\nusing AngularPowerSpectra\n\n# load up a mask\nnside = 256\nmask = readMapFromFITS(\"test/data/example_mask_1.fits\", 1, Float64)\n\n# pretend we are computing 143 GHz fields between two half-missions, hm1 and hm2\nm1 = PolarizedField(\"143_hm1\", mask, mask)\nm2 = PolarizedField(\"143_hm2\", mask, mask)\nworkspace = SpectralWorkspace(m1, m2)\n\n# compute the mode-coupling matrix\nM = mcm(workspace, \"TT\", \"143_hm1\", \"143_hm2\")","category":"page"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"covariance/#Covariance-Estimation","page":"Covariance","title":"Covariance Estimation","text":"","category":"section"},{"location":"covariance/","page":"Covariance","title":"Covariance","text":"(interface needs to be cleaned up)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"#AngularPowerSpectra","page":"Home","title":"AngularPowerSpectra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AngularPowerSpectra.jl computes mode-coupling matrices and covariance matrices for TT, TE, and EE spectra, using pseudo-C_ell methods (i.e. Hivon et al. 2002, Efstathiou 2006, Hamimeche and Lewis 2008).","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"CurrentModule = AngularPowerSpectra","category":"page"},{"location":"beams/#QuickPol","page":"Beams","title":"QuickPol","text":"","category":"section"},{"location":"beams/","page":"Beams","title":"Beams","text":"We provide utilities to compute beam matrices in the QuickPol formalism (Hivon et al. 2017). We introduce some additional steps here for computational efficiency. In this section, we use the indices ell ell ell such that we don't need to change indices at the end in order to match Hivon. Define a scaled version of the scan spectrum","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"W_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime  left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Define the matrix,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"beginaligned\nmathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell = (-1)^s_1 + s_2 + nu_1 + nu_2 sum_ell^prime  rho_j_1nu_1 rho_j_2 nu_2  W_ell^nu_1nu_2s_1s_2j_1j_2  \n qquadqquad times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"This matrix is symmetric, and does not depend on u_1 u_2. In practice, the m^prime are truncated at some low m_mathrmmax. We can then write the beam matrix in terms of mathbfXi,","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 = sum_j_1 j_2 s_1 s_2 frac2ell + 14pi _u_1hatb^(j_1)*_ell s_1 _u_2hatb^(j_2)*_ell s_2  frack_u_1 k_u_2k_nu_1 k_nu_2  mathbfXi^nu_1nu_2s_1s_2j_1j_2_ell^primeprimeell","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"With this definition, the beam matrices mathbfB are sub-blocks of the linear operator relating the cross-spectrum to the beamed cross-spectrum (Hivon+17 eq. 38),","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"tildeC^nu_1nu_2_ell^primeprime = sum_u_1u_2left(sum_ell mathbfB_ell^primeprimeell^nu_1nu_2 u_1 u_2 C_ell^u_1 u_2 right)","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"Note that the inner sum is just a matrix-vector multiplication.","category":"page"},{"location":"beams/","page":"Beams","title":"Beams","text":"quickpolΞ!\nquickpolW\nΞsum","category":"page"},{"location":"beams/#AngularPowerSpectra.quickpolΞ!","page":"Beams","title":"AngularPowerSpectra.quickpolΞ!","text":"quickpolΞ!(𝚵::AA, ν₁, ν₂, s₁, s₂, ω₁, ω₂)\n\nThis computes the Xi_ell^prime primeell matrix. It assumes rho has been absorbed into the omega terms.\n\nω₁: effective scan weights with spin s₁ + ν₁\nω₂: effective scan weights with spin s₂ + ν₂\n\n\n\n\n\n","category":"function"},{"location":"beams/#AngularPowerSpectra.quickpolW","page":"Beams","title":"AngularPowerSpectra.quickpolW","text":"quickpolW(alm₁::Alm{Complex{T}}, alm₂::Alm{Complex{T}})\n\nComputes a scaled spectrum of the scanned pattern.\n\nW_ell^nu_1nu_2s_1s_2j_1j_2 = sum_m^prime=-ell^prime^ell^prime  left(_s_1+nu_1tildeomega^(j_1)_ell^prime m^primeright)\n    left(_s_2+nu_2tildeomega^(j_2)_ell^prime m^primeright)^*\n\n\n\n\n\n","category":"function"},{"location":"beams/#AngularPowerSpectra.Ξsum","page":"Beams","title":"AngularPowerSpectra.Ξsum","text":"Ξsum(alm₁, alm₂, w3j₁, w3j₂)\n\nSum over ell and m of two a_ell m and nontrivial Wigner-3j vectors. This is  a step in computing the mathbfXi matrix. The rho factors are not  in this summation, as they can be pulled out.\n\nbeginaligned\n(Xi mathrmsum) = sum_ell^prime m^prime   W_ell^nu_1nu_2s_1s_2j_1j_2 times beginpmatrix ell  ell^prime  ell^primeprime \n     -s_1  s_1+nu_1   -nu_1 endpmatrix beginpmatrix\n     ell  ell^prime  ell^primeprime  -s_2  s_2+nu_2   -nu_2 endpmatrix\nendaligned\n\n\n\n\n\n","category":"function"}]
}
