        - 
        - @enum MapType ∅∅ II QQ UU TT PP TP
        - # Index for the W spectra, indexed X, Y, i, j, α, p, q, β
        - const WIndex = Tuple{MapType, MapType, String, String, MapType, String, String, MapType}
        - 
        - struct CovarianceWorkspace{T <: Real}
        -     field_names::NTuple{4, String}
        -     w_coeff::DefaultDict{Tuple{MapType, String, String, MapType}, Alm{Complex{T}}}
        -     W_spectra::DefaultDict{WIndex, PowerSpectrum{T}}
        - end
        - 
        - function CovarianceWorkspace(m_i::Field{T}, m_j::Field{T}, 
        -                              m_p::Field{T}, m_q::Field{T}) where {T}
 20444006     field_names = (m_i.name, m_j.name, m_p.name, m_q.name)
       80     lmax = 3 * m_i.maskT.resolution.nside - 1
        - 
        0     zero_alm = Alm(lmax, lmax, Zeros{Complex{T}}(numberOfAlms(lmax, lmax)))
        0     zero_cl = PowerSpectrum((Zeros{T}(lmax+1)))
        - 
     1360     return CovarianceWorkspace{T}(
        -         field_names, 
        -         DefaultDict{Tuple{MapType, String, String, MapType}, Alm{Complex{T}}}(zero_alm),
        -         DefaultDict{WIndex, PowerSpectrum{T}}(zero_cl)
        -     )
        - end
        - 
        - """
        - Compute the effective weight map copefficients and store them in the workspace.
        - """
        - function w_coefficients!(workspace::CovarianceWorkspace{T},
        -                          m_i::Field{T}, m_j::Field{T}, 
        -                          m_p::Field{T}, m_q::Field{T}) where {T <: Real}
        -     # generate coefficients w
      320     fields = Field{T}[m_i, m_j, m_p, m_q]
      320     names = [m_i.name, m_j.name, m_p.name, m_q.name]
        - 
 12583264     map_buffer = Map{T, RingOrder}(zeros(T, size(m_i.maskT.pixels)))  # reuse pixel buffer
        - 
        -     # XX, i, j, YY
        0     w = workspace.w_coeff
        - 
        0     for (i, name_i) in enumerate(names)
        0         for (j, name_j) in enumerate(names)
  1558459             if ((∅∅, name_i, name_j, TT) ∉ keys(w))
        0                 map_buffer.pixels .= fields[i].maskT.pixels
        0                 map_buffer.pixels .*= fields[j].maskT.pixels
      320                 w[∅∅, name_i, name_j, TT] = map2alm(map_buffer)  # allocate new alms
        -             end
        - 
        0             if i == j  # δᵢⱼ here, so we don't create arrays for this
      768                 if ((II, name_i, name_i, TT) ∉ keys(w))
        0                     map_buffer.pixels .= fields[i].maskT.pixels
        0                     map_buffer.pixels .*= fields[j].maskT.pixels
        0                     map_buffer.pixels .*= fields[j].σTT.pixels.^2
      160                     w[II, name_i, name_i, TT] = map2alm(map_buffer)
        -                 end
        -             end
        -         end
        -     end
        - end
        - 
        - 
        - function W_spectra!(workspace::CovarianceWorkspace{T}) where {T}
        -     # generate a list of jobs
      160     weight_indices = WIndex[]
       64     for (i, j, p, q) in permutations(workspace.field_names)
     4800         push!(weight_indices, (∅∅, ∅∅, i, j, TT, p, q, TT))
     1024         i == j && push!(weight_indices, (II, ∅∅, i, j, TT, p, q, TT))
     1472         p == q && push!(weight_indices, (∅∅, II, i, j, TT, p, q, TT))
     1024         i == j && p == q && push!(weight_indices, (II, II, i, j, TT, p, q, TT))
        -     end
        - 
        -     # use a thread safe dict to put it together
        0     W = workspace.W_spectra
      512     @threads for (X, Y, i, j, α, p, q, β) in weight_indices
        -         if (X, Y, i, j, α, p, q, β) ∉ keys(W)
        -             w1 = workspace.w_coeff[X, i, j, TT]
        -             w2 = workspace.w_coeff[Y, p, q, TT]
        -             if(typeof(w1) <: Alm && typeof(w2) <: Alm)
        -                 W[X, Y, i, j, α, p, q, β] = PowerSpectrum(alm2cl(w1, w2))
        -             end
        -         end
        -     end
        - 
  1143341     for k in keys(W)  # copy results over to workspace
  1013477         workspace.W_spectra[k] = W[k]
        -     end
        - end
        - 
        - """
        -     cov(workspace::CovarianceWorkspace{T}, m_i::Field{T}, m_j::Field{T}, 
        -         m_p::Field{T}=m_i, m_q::Field{T}=m_j; band=5) where {T <: Real}
        - 
        - Compute the covariance matrix between Cℓ₁(i,j) and Cℓ₂(p,q) for temperature.
        - 
        - # Arguments
        - - `m_i::Field{T}`: the array to search
        - - `m_j::Field{T}`: the value to search for
        - 
        - # Keywords
        - - `band::Integer`: compute the banded covariance matrix. Set to 0 for just the diagonal.
        - 
        - # Returns
        - - `Symmetric{Array{T,2}}`: covariance
        - """
        - function cov(workspace::CovarianceWorkspace{T}, 
        -              m_i::Field{T}, m_j::Field{T}, m_p::Field{T}, m_q::Field{T};
        -              lmax=nothing, band=nothing) where {T <: Real}
        - 
 14283441     w_coefficients!(workspace, m_i, m_j, m_p, m_q)
        0     W_spectra!(workspace)
        - 
       80     lmax = isnothing(lmax) ? (m_i.maskT.resolution.nside - 1) : lmax
        -     band = isnothing(band) ? lmax : band
        - 
        0     i, j, p, q = workspace.field_names
        0     W = workspace.W_spectra
      320     W_arr = (
        -         W[∅∅, ∅∅, i, p, TT, j, q, TT],
        -         W[∅∅, ∅∅, i, q, TT, j, p, TT],
        -         W[∅∅, TT, i, p, TT, j, q, TT],
        -         W[∅∅, TT, j, q, TT, i, p, TT],
        -         W[∅∅, TT, i, q, TT, j, p, TT],
        -         W[∅∅, TT, j, p, TT, i, q, TT],
        -         W[TT, TT, i, p, TT, j, q, TT],
        -         W[TT, TT, i, q, TT, j, p, TT]
        -     )
        -     
   520336     C = zeros(T, (lmax, lmax))
        0     return loop_covTT!(C, lmax, W_arr, band)
        -     # return C
        - end
        - cov(m_i::Field{T}, m_j::Field{T}) where {T <: Real} = cov(m_i, m_j, m_i, m_j)
        - 
        - 
        - """
        - Projector function for temperature.
        - """
        - function ΞTT(W_arr::PowerSpectrum{T}, w3j²::WignerSymbolVector{T, Int}, ℓ₁::Int, ℓ₂::Int) where T
        0     Ξ = zero(T)
        0     @inbounds for ℓ₃ in abs(ℓ₁ - ℓ₂):(ℓ₁ + ℓ₂)
        0         Ξ += (2ℓ₃ + 1) * w3j²[ℓ₃] * W_arr[ℓ₃]
        -     end
        0     return Ξ/(4π)
        - end
        - 
        - ΞTT(W_arr::PowerSpectrum{T,AA}, w3j²::WignerSymbolVector{T, Int}, ℓ₁::Int, 
        -     ℓ₂::Int) where {T, AA<:Zeros} = zero(T)
        - 
        - # inner loop 
        - function loop_covTT!(C::AbstractArray{T,2}, lmax::Integer, 
        -                  W_arr::NTuple{8,AbstractVector{T}}, 
        -                  band::Integer) where {T}
        - 
  2874512     thread_buffers = Vector{Vector{T}}(undef, Threads.nthreads())
       64     Threads.@threads for i in 1:Threads.nthreads()
        -         thread_buffers[i] = Vector{T}(undef, 2*lmax+1)
        -     end
        - 
  1049392     ℓpairs = [(ℓ₁,ℓ₂) for ℓ₁ in 1:lmax for ℓ₂ in ℓ₁:min(ℓ₁+band,lmax)]
        -     
       48     @threads for (ℓ₁,ℓ₂) in swap_triangular(ℓpairs)
        -         buffer = thread_buffers[Threads.threadid()]
        -         for ℓ₃ in abs(ℓ₁ - ℓ₂):(ℓ₁ + ℓ₂)
        -             w = WignerF(T, ℓ₁, ℓ₂, 0, 0)
        -             buffer_view = uview(buffer, 1:length(w.nₘᵢₙ:w.nₘₐₓ))
        -             w3j² = WignerSymbolVector(buffer_view, w.nₘᵢₙ:w.nₘₐₓ)
        -             wigner3j_f!(w, w3j²)
        -             w3j².symbols .= w3j².symbols .^ 2
        -             @inbounds for term_index in 1:8
        -                 C[ℓ₁, ℓ₂] += ΞTT(W_arr[term_index], w3j², ℓ₁, ℓ₂)
        -             end
        -         end
        -         C[ℓ₂, ℓ₁] = C[ℓ₁, ℓ₂]
        -     end
        0     return C
        - end
        - 
